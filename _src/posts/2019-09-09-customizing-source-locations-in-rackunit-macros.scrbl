#lang scribble/manual

Title: Customizing Source Locations in Rackunit Macros
Date: 2019-09-09T12:54:15
Tags: Racket, meta-programming

@require{../lib/common.rkt}

@require[@for-label[
  racket/base
  (except-in rackunit test-equal?)
]]

@; -----------------------------------------------------------------------------
@; Evaluator & Example

@define[rackunit-eval (module-language-evaluator 'racket/base)]
@define-syntax[example (examples/locations rackunit-eval)]

@example[
  #:hidden
  (require rackunit
           (for-syntax racket/base))
]


@; -----------------------------------------------------------------------------
@; Technical Terms

@; -----------------------------------------------------------------------------
@; Other Docs

@define[rackunit @docref['(lib "rackunit/scribblings/rackunit.scrbl")
  ]{rackunit}]

@; -----------------------------------------------------------------------------
@; External Links

@define[Racket @hyperlink["https://racket-lang.org/"]{Racket}]

@; =============================================================================
@; =============================================================================

Generating @rackunit tests with @Racket macros is an easy way to improve the
quality of your unit tests and your unit testing experience. Macros not only
save you the time and energy of writing boilerplate, but also allow you to
customize how tests are specified.

So what's the catch?

@rackunit's basic checks are, by and large, functions. They raise run-time
errors when they fail, and run-time errors report the source locations of
their call sites. In tests generated by purely pattern-based macros, these
locations point inside the macro definitions. Giving useful source locations
to macro-generated tests takes a little more work.

<!-- more -->

Let's test the @racket[equal?] function.

As a basic sanity check, I'd like to make sure @racket[equal?] works on
positive numbers, negative numbers, and zeros. Instead of writing each check
manually, I will write a macro that plugs expression fragments into a code
template. Generating this kind of boilerplate with a pattern-based macro is
usually straight-forward.

@example[
  (define-syntax-rule (test-equal?* [a b] ...)
    (test-case "equal?" (check equal? a b) ...))
]

@example[
  (test-equal?*
   [ 1  1]
   [-1 -1]
   [ 0  0])
]

When all the checks pass, as they did above, everything seems fine. But what
happens when a test fails?

@example[
  (test-equal?* [1 2])
]

The source location points to the @racket[check] invocation inside the macro
definition (inside the source for this article), but it would be more helpful
if it pointed to the offending clause of @racket[test-equal?*] instead. If
@racket[test-equal?*] was a procedural macro, it could copy the source
location from the syntax object of each clause directly onto the syntax object
of the corresponding @racket[check] invocation.

Converting a @racket[define-syntax-rule] macro into a procedural macro is a
simple substitution. Given a pattern-based macro definition of the form

@racketblock[
  (define-syntax-rule (id arg ...) expr)
]

an equivalent procedural macro definition is

@racketblock[
  (define-syntax (id stx)
    (syntax-case stx () [(_ arg ...) #'expr]))
]

Accordingly, @racket[test-equal?*] becomes:

@racketblock[
  (define-syntax (test-equal? stx)
    (syntax-case stx ()
      [(_ [a b] ...)
       #'(test-case "equal?" (check equal? a b) ...)]))
]

To get at the @racket[check] invocations, the body of the @racket[test-case]
needs to be broken down further. I will do that by generating a list of
@racket[check] invocation expressions and then splicing them in. That list can
be generated by mapping over the individual expressions bound to repeating
pattern variables (here, @racketid[a] and @racketid[b]) and combining them
with @racket[quasisyntax], @racket[unsyntax], and @racket[unsyntax-splicing].

@RACKETBLOCK[
  (define-syntax (test-equal? stx)
    (syntax-case stx ()
      [(_ [a b] ...)
       #`(test-case "equal?"
           #,@(for/list ([a-stx (syntax->list #'(a ...))]
                         [b-stx (syntax->list #'(b ...))])
                #`(check equal? #,a-stx #,b-stx)))]))
]

Next, I need to introduce the original clauses and copy their source locations
onto the corresponding @racket[check] invocations. According to the shape of
the syntax pattern @racket[(_ [a b] ...)], turning the original macro
invocation (bound to @racket[stx]) into a list and discarding its head will
produce the list of clauses. And finally, I can replace the
@racket[quasisyntax] wrapping the @racket[check] invocation with
@racket[quasisyntax/loc].

@example[
  #:escape UNSYNTAX
  (define-syntax (test-equal? stx)
    (syntax-case stx ()
      [(_ [a b] ...)
       #`(test-case "equal?"
           #,@(for/list ([clause-stx (cdr (syntax->list stx))]
                         [a-stx (syntax->list #'(a ...))]
                         [b-stx (syntax->list #'(b ...))])
                (quasisyntax/loc clause-stx
                  (check equal? #,a-stx #,b-stx))))]))
]

Now failed checks will report the location of the clause they came from.
(Again, check line and column number against the source to be sure.)
@example[
  (test-equal?
   [ 1  1]
   [-1 -1]
   [ 1  2]
   [ 0  0])
]
